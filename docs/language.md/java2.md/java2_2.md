---
layout: default
title: 연산자
parent: Java 심화
grand_parent: Language
nav_order: 3
---

<details open markdown="block">
  <summary>
    Table of contents
  </summary>
  {: .text-delta }
1. TOC
{:toc}
</details>

---

# I. 연산자
{: .no_toc }

---

## 연산자

### i. 연산자와 피연산자
{: .no_toc }

- **연산자란?**

> 연산을 수행하는 기호
>
> 피연산자로 연산을 수행하고나면 항상 결과값을 반환한다

<br/>

- **피연산자란?**

> 연산자의 작업 대상

```java
x + 3
//연산자: +
//피연산자: x, 3
```

<br/><br/>

### ii. 식과 대입 연산자
{: .no_toc }

- **식이란?**

> 연산자와 피연산자를 조합하여 계산하고자 하는 것을 표현한 것

<br/>

- **대입연산자란?**

> **=**을 사용하여 오른쪽의 값을 왼쪽에 대입하여 저장한다
>
> 식의 결과값 저장을 위해 아래처럼 표현한다 _새미콜론을 이용하여 문장으로 만들어주어야 한다_

```java
y = x * 3 + 5;
```

<br/><br/>

### iii. 연산자의 종류
{: .no_toc }

- **기능별 분류**

> 산술 : 사칙연산, 나머지연산
>
> 비교 : 크고 작음과 같고 다름을 비교
>
> 논리 : 그리고, 또는 등으로 조건을 연결
>
> 대입 : 우변읙 값을 좌변에 저장
>
> 기타 : 형변환연산자, 삼항연산자, instanceof연산자

<br/>

- **피연산자 개수별 분류**

> 단항연산자
>
> 이항연산자
>
> 삼항연산자

```java
-2-5
//단항연산자: 부호연산자(-2의 -부호연산자)
//이항연산자: 뺄셈연산자(-2,-5의 -산술연산자)
```

<br/><br/>

### iv. 연산자의 우선순위와 결합규칙
{: .no_toc }

- **연산자의 우선순위**

> 아래는 일반적인 상식선에서 해결되는 순서이다
>
> **산술**(덧셈/나눗셈 - 곱셈/나눗셈) - **비교** - **논리** - **대입**
>
> **단항 - 이항 - 삼항**

```java
-x+3
//부호 - 덧셈
x+3*y
//곱셈 - 덧셈
X+3 > y-2
//덧셈 - 뺄셈 - 비교
x > 3 && x < 5
//비교 - 논리
result = x+y*3
//곱셈 - 덧셈 - 대입
```

<br/>

{: .highlight-title }
> 🥕
>
> 아래는 주의해야 할 연산자 우선순위이다

```java
x << 2+1
// x << (2+1)
```

> 덧셈/뺄셈 - 쉬프트

```java
data & 0xFF == 0
// data & (0xFF == 0)
```

> 비교 - 비트

```java
x<-1 || x>3 && x<5
//x<-1 || (x>3 && x<5)
```

> and - or

- **연산자의 결합규칙**

> 연산자는 대부분 왼쪽에서 오른쪽의 순서로 수행한다
>
> 단, 단항연산자, 대입연산자 제외

<br/><br/>

### v. 산술 변환
{: .no_toc }

> 연산 전에 피연산자의 타입이 자동적으로 형변환되는 것 (쉬프트연산자, 증감연산자 제외)
>
> 일반 산술 변환은 아래 규칙을 따른다
>
> 1. 두 피연산자의 타입을 보다 큰 타입으로 일치시킨다
>
> 2. 피연산자의 타입이 int보다 작으면 int로 변환시킨다

```
byte + short -> int + int
```

---

## 단항 연산자

### i. 증감 연산자
{: .no_toc }

- **증감연산자란?**

> 증가연산자(++): 피연산자의 값을 1 증가시킨다
>
> 감소연산자(--): 피연산자의 값을 1 감소시킨다

<br/>

- **전위형과 후위형**

> 전위형(++i, --i): 값 증가 후 참조
>
> 후위형(i++, i--): 값 참조 후 증가

```java
j = ++i; 
//++i;
//j = i;

j = i++;
//j = i;
//i++;
```

<br/>

{: .note-title }
> 전위형과 후위형 예시
>
> 아직 헷갈리므로 출력을 통해 둘의 차이를 확인해보자

```java
class Main {
	public static void main(String[] args) {
		int i = 5;
		int j = 5;

		System.out.println(i++); //i에 저장된 값을 넘겨준 후 증가함
		System.out.println(++j); //j값을 증가한 뒤 값을 넘겨줌
		System.out.printf("i=%d, j=%d", i, j); //i도 증가한 모습
	}
}
```

```java
5
6
i=6, j=6
```


{: .warning-title }
> ❗️
>
> 1. 증감연산자를 최소화할 것
>
> 2. 식에 두 번 이상 포함된 변수에 증감연산자의 사용은 자제할 것

<br/><br/>

### ii. 부호 연산자
{: .no_toc }

> 부호연산자는 +와 -가 있지만 실질적으로 +는 사용하지 않는다
>
> 또한, boolean과 char을 제외한 기본형에만 사용할 수 있다

---

## 산술 연산자

### i. 사칙 연산자
{: .no_toc }

> **+, -, /, ***이 있으며, 숫자뿐만 아니라 문자에도 유니코드를 통해 사칙연산자를 사용할 수 있다
>
> 사칙연산은 상식선에서 알고있는 것들이기 때문에 주의해야할 점을 정리한다

- **형변환**

1. int형보다 작은 두 타입의 연산과 식

```java
byte a = 10;
byte b =20;

byte c = (a + b);
//byte = int + int 이므로 에러발생

byte c = (byte) (a + b);
```

<br/>

{:style="counter-reset:none"}
2. 오버플로우

```java
long a = 1_000_000 * 1_000_000; //오버플로우 발생
long b = 1_000_000 * 1_000_000L;
```

> **필요로 하는 명시적 형변환을 해주지 않을 경우 오버플로우가 발생할 수 있다**
> 
> a의 경우 int형끼리 계산한 값이기 때문에 오버플로우가 발생한다
>
> b의 경우 long타입이 하나 껴있으므로 자동형변환에 의해 올바른 값을 구할 수 있다

```java
int a = 1_000_000;

int result1 = a * a / a; //오버플로우 발생
int result2 = a / a * a;
```

> **사칙연산의 순서에 의해 오버플로우가 발생할 수 있다**
>
> result2는 result1과 다르게
>
> 연산과정에서 int형 타입의 범위를 벗어나지 않았기 때문에 정상값이 출력된다

<br/>

<br/><br/>

### ii. 나머지 연산자
{: .no_toc }



---

## 비교 연산자

### i. 대소비교 연산자
{: .no_toc }



<br/><br/>

### ii. 등가비교 연산자
{: .no_toc }


---

## 논리 연산자

### i. 논리 연산자
{: .no_toc }



<br/><br/>

### ii. 비트 연산자
{: .no_toc }

---

## 그 외의 연산자

### i. 조건 연산자
{: .no_toc }



<br/><br/>

### ii. 대입 연산자
{: .no_toc }