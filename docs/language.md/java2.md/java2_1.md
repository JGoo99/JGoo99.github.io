---
layout: default
title: 변수
parent: Java 심화
grand_parent: Language
nav_order: 2
---

<details open markdown="block">
  <summary>
    Table of contents
  </summary>
  {: .text-delta }
1. TOC
{:toc}
</details>

---

# I. 변수
{: .no_toc }

---

## 변수와 상수

### i. 변수란?
{: .no_toc }

> **단 하나의 값을 저장할 수 있는 메모리 공간**
>
> 이 수는 변경할 수 있기 때문에 변수라고 명명

<br/><br/>

### ii. 변수의 선언과 초기화
{: .no_toc }

- **변수의 선언**

> 변수를 사용하기 위해 변수 타입과 이름을 정하는 것

```java
int age;
//변수타입 변수이름
```

<br/>

- **변수의 초기화**

> **변수를 사용하기 전에 처음으로 값을 저장하는 것**
>
> 오른쪽의 값을 왼쪽에 대입한다

```java
int age = 24, year = 2023;
```

<br/>

{: .new-title }
> 두 변수의 값 교환하기
>
> x와 y에 각각 초기화된 값을 바꿔보자

```java
class Main {
  public static void main(String[] args) {
    int x=5, y=10;
    int temp = 0;

    System.out.println("x:" + x + " y:" + y);

    temp = x; 
    x = y;
    y = temp;

    System.out.println("x:" + x + " y:" + y);
  }
}
```

```java
x:5 y:10
x:10 y:5
```

> 단순히 x=y, y=x로 초기화 하는 것이 아니라
>
> 임시저장소 temp를 선언하여 두 변수 x,y의 값을 교환해야 한다

<br/>

- **변수의 기본값**

| 자료형 | 기본값 |
|------|-------|
| boolean | false |
| char | '\u0000' |
| byte, short, int | 0 |
| long | 0L |
| float | 0.0f |
| double | 0.0d 또는 0.0 |
| 참조형 변수 | null |

<br/><br/>

### iii. 변수의 명명규칙
{: .no_toc }

- **대소문자**가 구분되며 **길이에 제한이 없다**

- 예약어를 사용해서는 안 된다

- **숫자로 시작**해서는 **안 된다**

- 특수문자는 **_와 $**만 허용된다

- **클래스** 이름의 첫글자는 항상 **대문자**로 한다

- 여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자로 한다

- **상수**의 이름은 **모두 대문자**로 한다 (여러 단어로 이루어진 경우 _로 구분한다)


---

## 변수의 타입

### i. 기본형과 참조형
{: .no_toc }

- **자료형**

> data의 type에 따라 값이 저장될 공간의 크기와 저장형식을 정의한 것으로
>
> 자료형은 크게 기본형과 참조형으로 나뉜다

<br/>

- **참조형**

> 어떤 값이 저장된 주소를 값으로 저장하는 자료형이다 

```java
Data today = new Data();
//클래스이름 변수이름 = 생성된 객체의 주소
```

<br/>

- **기본형**

> 실제 값을 저장하는 자료형으로 문자형, 정수형, 실수형, 논리형 등이 있다

|분류     |타입                       |
|:-------|:-------------------------|
|논리형    |boolean                   |
|문자형    |char                      |
|정수형    |byte, short, **int**, long|
|실수형    |float, **double**         |

> 기본형의 종류와 크기는 아래와 같다

|종류/크기  |  1byte  |  2byte  |  4byte  |  8byte  |
|:-------:|:-------:|:-------:|:-------:|:-------:|
|논리형     |boolean  |         |         |         |
|문자형     |         |char     |         |         |
|정수형     |byte     |short    |**int**  |long     |
|실수형     |         |         |float    |**double**|

<br/><br/>

### ii. 상수와 리터럴
{: .no_toc }

- **상수**

> 값을 저장할 수 있는 공간 (단, 값을 변경할 수 없으며, **선언과 동시에 초기화해야 한다**)

```java
final int MAX_VALUE = 100; 
```

<br/>

- **숫자 리터럴**

> 숫자 그 자체의 값으로, 선언 시 접미사가 필요한 경우가 있다
>
> 접미사가 필요한 데이터 타입: **long, float** (int와 double로 자동 설정됨)

{: .warning-title }
> Error
>
> 리터럴 값의 범위 > 변수의 타입

<br/>

- **문자/문자열 리터럴**

> 문자 리터럴: ''로 감싼 한 문자 이상의 데이터
>
> 문자열 리터럴: ""로 감싼 빈 문자열 이상의 데이터

{: .important-title }
> 🐷
>
> 기본/참조형 구별 없이 **어떤 타입의 변수도 문자열과 덧셈하면 결과는 문자열이 된다**
>
> 단, 덧셈연산은 왼쪽부터 수행하므로 그 결과값이 달라질 수 있다

```java
System.out.println( 7 + 7 + "" );
System.out.println( "" + 7 + 7 );
```

```java
14
77
```

<br/><br/>

### iii. 형식화된 출력
{: .no_toc }

> 지금까지는 println()을 사용하였다 이번에는 형식화하여 출력하는 printf()를 알아보자

<br/>

- **printf()**

> 기능: 지시자를 통하여 변수의 값을 여러 가지 형식으로 변환하여 출력한다
>
> 특징: println()과 다르게 줄바꿈을 하지 않는다

<br/>

- **지시자**

> 값을 어떻게 출력할 것인지 정하는 역할

| 지시자 | 설명 |
|:----:|:----------:|
| %b      | boolean  |
| %d      | 10진 정수  |
| %o      | 8진 정수   |
| %x, %X  | 16진 정수  |
| %f      | 부동 소수점 |
| %e,%E   | 지수 표현식 |
| %c      | 문자      |
| %s      | 문자열     |

```java
System.out.printf("age: %d year: %d, 24, 2023)
```

<br/><br/>

### vi. 화면에서 입력받기
{: .no_toc }

> Scanner를 활용한 콘솔 입력받기

```java
String input = sc.nextLine(); 
int num = Integer.parseInt(input); // 입력받은 내용을 input타입의 값으로 변환
```

> Scanner는 nextInt()나 nextByte() 등 데이터 타입별로 입력받을 수 있다
>
> 단 연속적으로 입력받을 경우 데이터 타입을 지정하는 것은 복잡할 수 있다
>
> 따라서 아래처럼 nextLine()을 이용하여 String으로 입력받은 후 형변환처리를 하자

```java
import java.util.Scanner;

public class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);

    System.out.println("두 자리 정수를 입력하시오");
    String input = sc.nextLine();
    int num = Integer.parseInt(input);

    System.out.println("입력내용: "+input);
    System.out.printf("num= %d%n", num);
  }
}
```

```java
두 자리 정수를 입력하시오
22
입력내용: 22
num= 22
```

---

## 진법

### i. 10진법과 2진법
{: .no_toc }

> 지금까지 리터럴을 저장할 때 10진법을 사용한 것 같았지만
>
> 사실 10진 숫자들은 모두 컴퓨터가 이해할 수 있는 2진법으로 해석되어 저장되어 왔다
>
> 아래 표를 통해 2진법을 살펴보자

| 2진법 | 10진법 |
|:----:|:-----:|
| 0 | 0 |
| 1 | 1 |
| 10 | 2 |
| 11 | 3 |
| 100 | 4 |
| 101 | 5 |
| 110 | 6 | 
| 111 | 7 |
| 1000 | 8 | 
| 1001 | 9 |
| 1010 | 10 |

<br/><br/>

### ii. 비트와 바이트
{: .no_toc }

> **비트**: bit, 한 자리의 2진수
>
> **바이트**: byte, 여덟 자리의 2진수 (=8bit)
>
> **워드**: word, CPU가 한 번에 처리할 수 있는 데이터의 크기

<br/><br/>

### iii. 8진법과 16진법
{: .no_toc }

> 2진법은 두 개의 숫자로만 표현하기 때문에 자릿수가 너무 많아진다는 단점이 있다
>
> 이 단점을 보안하기 위해 나온 것이 8진법과 16진법이다

| 2진법 | 8진법 | 10진법 | 16진법 | 
|:----:|:----:|:----:|:----:|
| 0 | 0 | 0 | 0 |
| 1 | 1 | 1 | 1 |
| **10** | 2 | 2 | 2 | 
| 11 | 3 | 3 | 3 |
| 100 | 4 | 4 | 4 |
| 101 | 5 | 5 | 5 |
| 110 | 6 | 6 | 6 |   
| 111 | 7 | 7 | 7 |
| 1000 | **10** | 8 | 8 |
| 1001 | 11 | 9 | 9 |
| 1010 | 12 | **10** | A | 
| 1011 | 13 | 11 | B |
| 1100 | 14 | 12 | C |
| 1101 | 15 | 13 | D |
| 1110 | 16 | 14 | E |
| 1111 | 17 | 15 | F | 
| 10000 | 20 | 16 | **10** |

<br/>

- **2진수의 8/16진수 변환**

> **2진수 > 8진수**: 3자리씩 끊어서 그에 해당하는 8진수로 바꾸기
>
> **2진수 > 16진수**: 4자리씩 끊어서 그에 해당하는 16진수로 바꾸기

```java
1010101100

//8진수로 바꾸기
1_010_101_100 //1254

//16진수로 바꾸기
10_1010_1100 //2AC
```

---

## 기본형

### i. 논리형
{: .no_toc }

> Boolean형 변수 하나 뿐으로 **false**와 **true** 중 하나를 저장할 수 있다
>
> 기본값은 false이며, 대문자를 사용하면 에러가 발생한다

```java
boolean power = true;
boolean checked = False; //Error
```

<br/><br/>

### ii. 문자형
{: .no_toc }

> char형 변수 하나 뿐으로 단 하나의 문자만 저장할 수 있다

```java
char ch = 'A';
```

{: .new-title }
> 문자와 유니코드
>
> 위의 A는 문자로 저장되는 것이 아니라 **유니코드 65**로 저장된다
>
> 문자를 숫자로 변환하여 저장하는 것을 **인코딩**
>
> 숫자를 다시 문자로 출력하는 것을 **디코딩**이라고 한다
>
> 실제로 그러한지 문자와 유니코드를 출력해보자

```java
char ch = '가';
System.out.printf("%c = %d(%#X)", ch, (int)ch, (int)ch);
```

```java
가 = 44032(0XAC00)
```

<br/>

- **특수문자 저장하기**

> 특수문자는 백슬레시를 사용하여 저장해야 한다
>
> 아래 예시와 표를 참고하자

```java
char tab = '\t';
//실제로는 두 개의 문자이지만 하나의 문자로 취급되어 자장된다
```

| 특수문자 | 문자 리터럴 |
|:------:|:--------:|
| tab | \t |
| backspace | \b |
| form feed | \f |
| new line | \n |
| carriage return | \r |
| 역슬래쉬 | \\\ |
| 작은 따옴표 | \\' |
| 큰 따옴표 | \\" |
| 유니코드(16진수 문자) | \u |

```java
System.out.println("tab :" + '\t' + "."); //tab

System.out.println("backspace :" + "." + '\b' + ".");

System.out.println("form feed :" + '\f' + ".");
		//다음페이지로 넘어감
System.out.println("new line :" + '\n' + ".");

System.out.println("carriage return :" + '\r' + ".");
		//맨 왼 쪽으로 이동
System.out.println("역슬래쉬 :" + '\\');

System.out.println("따옴표 :" + '\'' + '\"' );
```

```java
tab :	.
backspace :.
form feed :.
new line :
.
.
역슬래쉬 :\
따옴표 :'"
```

<br/><br/>

### iii. 정수형
{: .no_toc }

> byte, short, int, long 총 네가지로 각 자료형의 저장 수용 범위가 다르다
>
> 저장 수용범위를 정리해둔 표를 아래에 첨부한다

[Link button](https://jgoo99.github.io/docs/language.md/java1.md/data_type/#ii-%EB%B3%80%EC%88%98-%EC%84%A4%EC%A0%95-%EB%B0%A9%EB%B2%95){: .btn .btn-outline }

<br/>

- **변수 선택 기준**

> **정수형 변수는 int형으로 선언하자**
>
> 만약, 성능보다 **메모리 절약**이 필수인 경우에 데이터 범위에 따라 **byte나 short**로 선언
>
> 혹은, int형 보다 **큰 수**를 저장하고 싶을 땐 **long**을 선언

{: .important-title }
> 왜 int형이 효율적인가요
>
> jvm의 연산자 스택은 4byte단위로 피연산자를 저장하기 때문에
>
> byte나 short인 경우 4byte로 변환하여 연산 수행 (int와 동일)
>
> 또한, byte나 short의 연산 과정에서 **오버플로우**가 발생할 수 있음
>
> _**오버플로우**: 타입이 표현할 수 있는 값을 넘어서는 것(결과값 오류)_

<br/><br/>

### vi. 실수형
{: .no_toc }

> float, double 두 가지로, 각 자료형의 저장 수용 범위가 다르다
>
> float은 소수점 이하 7자리, double은 소수점 이하 15자리까지 표현 가능하다

<br/>

- **변수 선택 기준**

> 연산속도의 향상과 메모리 절약: float
>
> 더 큰 값이나 더 높은 정밀도: double

<br/>

{: .new-title }
> 🤔
>
> **왜 정수형 타입과 같은 byte로 더 정밀하고 큰 수를 표현할 수 있는걸까?**
>
> 저장 방식이 다르기 때문이다
>
> 정수형 데이터 타입은 부호, 값 두 부분으로 나누어 수를 표현하고
>
> 실수형 데이터 타입은 부호, 지수, 가수 세 부분으로 나누어 수를 표현한다

---

## 형변환

### i. 형변환이란?
{: .no_toc }

> **변수 또는 상수의 타입을 다른 타입으로 변환하는 것**
>
> _서로 다른 타입간의 연산 수행의 경우도 있기 때문이다_

<br/><br/>

### ii. 형변환 방법
{: .no_toc }

> **(타입)피연산자**
>
> 이때 괄호는 캐스트연산자 or 형변환연산자라고 하며, 형변환은 캐스팅이라고도 한다

```java
int i = 10;
byte b = (byte)i;
//형변환을 사용해도 피연산자 i의 초기값은 바뀌지 않는다
```

<br/><br/>

### iii. 정수형 간의 형변환
{: .no_toc }

> 작은 타입에서 큰 타입으로의 캐스팅은 값 손실이 없다
>
> 반대로, 큰 타입에서 작은 타입으로의 캐스팅은 값 손실이 있을 수 있다
>
> **int(4byte) -> byte(1byte)** 예시를 통해 확인하자

```java
for (int j = 126; j < 130; j++) {
  int i =+ j;
  byte b = (byte) i;
  System.out.printf("%d -> %d\n", i, b);

  System.out.println(Integer.toBinaryString(i)); //10진수를 2진수로 변환하는 매소드
  System.out.println(Integer.toBinaryString(b));
  System.out.println();
}
```

```java
126 -> 126
1111110
1111110

127 -> 127
1111111
1111111

128 -> -128 //오버플로우
10000000
11111111111111111111111110000000 //음수의 경우 빈 공간을 1로 채운다(부호의 유지)

129 -> -127
10000001
11111111111111111111111110000001
```

<br/><br/>

### vi. 실수형 간의 형변환
{: .no_toc }

> 실수형 역시 작은 타입에서 큰 타입으로의 캐스팅은 값 손실이 없다
>
> 반대로, 큰 타입에서 작은 타입으로의 캐스팅은 값 손실이 있을 수 있다
>
> 값 손실 예시: 반올림, float의 범위보다 큰 경우(무한대나 0이 됨)
>
> 아래 예시를 통해 확인하자

```java
float f = 9.1234567f;
double d = 9.1234567;
double d2 = (double) f;

System.out.printf("f  = %20.18f\n", f); 
System.out.printf("d  = %20.18f\n", d);
System.out.printf("d2 = %20.18f\n", d2);
```

```java
f  = 9.123456954956055000 //반올림으로 인해 저장 시에 값손실이 일어남
d  = 9.123456700000000000
d2 = 9.123456954956055000 //형번환을 해도 저장 시에 이미 값이 달라졌기 때문에 같은 값 출력
```

<br/><br/>

### v. 정수형과 실수형 간의 형변환
{: .no_toc }

- **정수형을 실수형으로**

> 값의 범위가 훨씬 크기때문에 무리없이 변환 가능하다
> 
> 단 int형(최대 10자리)과 float형(최대 7자리)의 **정밀도 차이로 인한 오류**가 발생할 수 있다
>
> 따라서, **8자리 이상의 값을 변환하고 싶을 땐 double형으로 변환**해야 한다
>
> 아래 예시를 통해 8자리 이상의 값을 변환했을 경우를 살펴보자

```java
int i = 91234567; //8자리 정수

float f = (float) i;
double d = (double) i;

System.out.println((int)f);
System.out.println((int)d);
```

```java
91234568 //형변환 시 반올림됨
91234567
```

<br/>

- **실수형을 정수형으로**

> 실수의 소수점 이하 값은 버림된다 (반올림x)
>
> 또한, 정수형 데이터타입의 범위를 넘는 경우 오버플로우가 발생한다

```java

```

<br/><br/>

### vi. 자동 형변환
{: .no_toc }

> 타입이 다른 데이터 간의 산술 시에는 명시적으로 형변환을 해주는 것이 원칙
>
> 그러나 범위가 **좁은 데이터에서 넓은 데이터로의 변환**은 자동적으로 이루어진다
>
> 즉, **기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환한다**

![java1](https://github.com/JGoo99/java-project/assets/126454114/b384845d-7d5f-44bc-826d-460c841c7e5c)

> 이 외의 형변환 규칙
>
> 1. boolean을 제외한 나머지 7개의 기본형은 서로 형변환이 가능하다
>
> 2. 기본형과 참조형은 서로 형변환할 수 없다